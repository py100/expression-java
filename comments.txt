a.问题描述
b.最终解决方法
c.如何通过交流找到解决方法

(1):
--a:最初用vector<Node> 存储每一个加号连接的乘积项，但是elemeteAt 方法只是返回vector中数据类型的拷贝而无法修改到实际的内容。
--b
----1:解决方法1：重新开辟一个临时的vector 记录更改后的项，所有操作结束之后替换原来的项。
----2:解决方法2：替换vector 为 Arraylist 使用其 get 方法 可以直接获取到容器中实际的对象进行修改
--c:先通过讨论的出一个可行的即便是很低效率的方法，然后实现之后再进行讨论并得出可以更改一下存储的方式提高其效率


(2):
--a:完成了基础表达式之后需要增加其对负系数的支持，最开始的想法是更改代码部分对负号进行处理，但是这样会有很多的代码量，并且代码很多重复部分，不是一个很好的方法，于是便舍弃了该方法进行讨论。
--b:在输入表达式之后我们将所有负号的前面加入一个'+', 这样我们就只需要增加两行代码就可以是我们原来的程序完美的支持负号。
--c:我们先是想到了在减号前面增加一个加号的做法，但是没有发现如果-紧跟着一个变量，我们需要在-后面加上一个1*，这个方法是经过讨论得出的，免去了之后调试去发现这个bug得时间


(3):
--a:如何处理一个长串得表达式，如果一个一个字符得遍历字符那么情况太过分散不好考虑。
--b:将最初的表达式按照+拆分，再按照*拆分，然后对于每个+之间的表达式存储为一个node保存其未知数和其系数
--c:最开始只想到了按照+拆分，在实现的过程中队友提到了可以对于+拆分之后的项按照*拆分，这样我们得到的就是所有的最简项的数组了，真正将操作最简化

